<!DOCTYPE html>
<html lang="en">
<head>
    <meat charset="utf-8"></meat>
    <title>Pong</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" href="./public/css/style.css">
</head>
<body style="background-color: #343541;">
    <div class="ttwait">
        <p class="waitcolor" >Waiting for opponent...</p>
    </div>
    <div class="tthead">
        <h1 style="color: #FFB6C1; font-family: Arial Rounded MT Bold; font-size: 50px;">Guess First</h1>
    </div>
    <!-- Image Popup Modal -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <div id="container"></div>
            <div class="otp-container">
                <input class="otp-input" type="text" maxlength="1" oninput="moveToNextOrPrevious(this, 'otpInput2')">
                <input class="otp-input" type="text" maxlength="1" id="otpInput2" oninput="moveToNextOrPrevious(this, 'otpInput3')" onkeydown="moveToPreviousOnBackspace(this)">
                <input class="otp-input" type="text" maxlength="1" id="otpInput3" oninput="moveToNextOrPrevious(this, 'otpInput4')" onkeydown="moveToPreviousOnBackspace(this)">
                <input class="otp-input" type="text" maxlength="1" id="otpInput4" oninput="checkOTP()" onkeydown="moveToPreviousOnBackspace(this)">
            </div>
            <div id="result"></div>
        </div>
    </div>
<script src="/socket.io/socket.io.js"></script>
<script src="room.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
    const socket = io('/game'); 
    let  width = 0, height = 0, player_width = 0, player_height;
    const pi = Math.PI;
    const UP = 38, DOWN = 40;
    let canvas, ctx, keystate;
    let ball;
    let message = "";
    let score1 = 0, score2 = 0;
    let username = [];
    let space_down = false;
    let revealPercentage1 = 1;
    let revealPercentage2 = 1;
    let playerIds = [];

    // send key code to server.
    $('body').on('keydown', (e) => {
        socket.emit('keydown', e.keyCode);
        console.log(e.keyCode);
        if(e.keyCode == 32) {
            let space = 0;
            if(space_down == false) {
                space = 1;
                space_down = true;
            } else {
                space = 0; 
            }
            socket.emit('space_event', space)
        }
    });
    $('body').on('keyup', (e) => {
        socket.emit('keyup', e.keyCode);
        if(e.keyCode == 32) {
            space_down = false;
        }
    });
    let players = [];
    class player {
        constructor (xpos = 0, ypos = 0) {
            this.x = xpos;
            this.y = ypos;
            this.width = 0 
            this.height = 0;
            this.username = "";
        }
        init() {
        }
        update() {
            this.width = player_width;
            this.height = player_height;
        }
        draw() {
    // Set the fill color based on the player index
    if (this.x < width / 2) {
        ctx.fillStyle = "#FFB6C1"; // Magenta for left paddle
    } else {
        ctx.fillStyle = "#ADD8E6"; // Green for right paddle
    }
    const cornerRadius = 10; // You can adjust this value
    ctx.beginPath();
    ctx.moveTo(this.x + cornerRadius, this.y);
    ctx.lineTo(this.x + this.width - cornerRadius, this.y);
    ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + cornerRadius);
    ctx.lineTo(this.x + this.width, this.y + this.height - cornerRadius);
    ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - cornerRadius, this.y + this.height);
    ctx.lineTo(this.x + cornerRadius, this.y + this.height);
    ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - cornerRadius);
    ctx.lineTo(this.x, this.y + cornerRadius);
    ctx.quadraticCurveTo(this.x, this.y, this.x + cornerRadius, this.y);
    ctx.fill();
}
    };
    ball = {
        x: null,
        y: null,
        vel: null,
        side: 0,
        speed: 8,
        update: function () {
        },
        draw: function() {
            ctx.beginPath();
            ctx.arc(this.x + this.side / 2, this.y + this.side / 2, this.side / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    };
    function init() {
        ball.side = player_width;
        ball.x = (width - ball.side) / 2;
        ball.y = (height - ball.side) / 2;
        console.log(player_width);
        ball.vel = {
            x: ball.speed,
            y: 0
        };
    }
    function update() {
        ball.update();
        for(p in players) {
            players[p].update();
        }
    }
    function draw() {
        // Draw the background image
        var modal = document.getElementById('imageModal');
        modal.style.display = 'block';
        // ctx.drawImage(bgImage, 0, 0, width, height); // Uncomment this line if you want to draw the background image first
        const margin = 100;
        ctx.fillStyle = "rgba(0, 0, 0, 0.419)";
        ctx.fillRect(0, 0, width, height);
        ctx.save();
        ctx.fillStyle = "#fff";
        for(p in players){
            players[p].draw();
        }
        ctx.fillStyle = "#fff";
        ball.draw();
        var mid_width = 4;
        var x = (width - mid_width) * 0.5;
        var y = 0;
        var step = height / 20;
          // Messages
        ctx.font = "30px Arial";
        ctx.fillText(message, 0, height - 50);
        // Scores
        ctx.font = "50px Arial";
        ctx.fillStyle = "#fff";
        // ctx.fillText(score1, width / 4 - ctx.measureText(score1).width / 2, height / 5);
        ctx.fillStyle = "#fff";
        // ctx.fillText(score2, 3 * width / 4 - ctx.measureText(score2).width / 2, height / 5);
        // Usernames: Centered on both sides
        ctx.font = "30px Arial";
        // ctx.fillStyle = "#ff00ff"; // Magenta color for left stick bars
        const username1Width = ctx.measureText(username[0]).width;
        // ctx.fillText(username[0], width / 4 - username1Width / 2, height / 8);
        // ctx.fillStyle = "#00ff00"; // Green color for right stick bars
        const username2Width = ctx.measureText(username[1]).width;
        // ctx.fillText(username[1], 3 * width / 4 - username2Width / 2, height / 8);
        ctx.restore();
        // ctx.fillText(username[0], width / 4 - username1Width / 2, height / 8);
        // ctx.fillText(username[1], 3 * width / 4 - username2Width / 2, height / 8);
        ctx.restore();
        // Draw the background image again to cover up any other drawn elements
    // ctx.drawImage(bgImage, 0, 0, width, height);
    }
    function createGrid() {
            const container = document.getElementById("container");

            for (let i = 0; i < 2500; i++) {
                const block = document.createElement("div");
                block.classList.add("block");
                container.appendChild(block);
            }
        }
        function revealBlocks(revealPercentage) {
            // Maintain a list of previously revealed blocks
            revealPercentage=revealPercentage;
            const previouslyRevealedBlocks = [];
            const inputNumber = revealPercentage;
            const blocks = document.querySelectorAll(".block");
            // Randomly select and reveal the specified number of blocks
            var delayInMilliseconds = 1000;
            const blocksToReveal = [];
            for (let i = 0; i < inputNumber; i++) {
                // Check if the block has already been revealed
                let blockIndex = Math.floor(Math.random() * blocks.length);
                while (previouslyRevealedBlocks.includes(blockIndex)) {
                blockIndex = Math.floor(Math.random() * blocks.length);
                }
                previouslyRevealedBlocks.push(blockIndex);
                blocksToReveal.push(blocks[blockIndex]);
               
            }
            // Set the background color of the selected blocks to transparent
            blocksToReveal.forEach(block => {
                block.style.transition = "background-color 0.7s ease-in-out";
                block.style.backgroundColor = "transparent";
             
            });
            }

        window.addEventListener("load", createGrid);
        function showImagePopup() {
            var modal = document.getElementById('imageModal');
            modal.style.display = 'block';
            revealBlocks();
        }
        // Function to handle submitting guesses
        function submitGuess() {
            var guess = document.getElementById('guessInput').value;
            // TODO: Check if the guess is correct and take appropriate actions
            // Close the modal after processing the guess
            var modal = document.getElementById('imageModal');
            modal.style.display = 'none';
        }
        var bgImage = new Image();
        bgImage.src = "https://upload.wikimedia.org/wikipedia/en/0/0a/Flappy_Bird_icon.png";
        function main() {
            canvas = document.createElement("canvas");
            ctx = canvas.getContext("2d");
            document.body.appendChild(canvas);
            var bgImage = new Image();
            bgImage.src = "https://upload.wikimedia.org/wikipedia/en/0/0a/Flappy_Bird_icon.png";
            bgImage.onload = function() {
                ctx.drawImage(bgImage, 0, 0, width, height);
            };
            var loop = function() {
                canvas.width = width;
                canvas.height = height;
                update();
                draw();
                window.requestAnimationFrame(loop, canvas);
            }
            window.requestAnimationFrame(loop, canvas);
        }
    main();
    socket.on('config', (config) => {
        width         = config.screen_width;
        height        = config.screen_height;
        player_width  = config.player_width;
        player_height = config.player_height;
        end_point     = config.end_point;
        init();
    })
    socket.on('usernames', (usernames) => {
        username.push(usernames[0]);
        username.push(usernames[1]);
    })
    socket.on('game_over', (msg) => {
        message = msg;
        // Create the button
        let leave_button = document.createElement("button");
        leave_button.innerHTML = "Go Back To Menu";
        // Append somewhere
        let body = document.getElementsByTagName("body")[0];
        body.appendChild(leave_button);
        // Add event handler
        leave_button.addEventListener("click", function () {
            window.location.href = '/';
        });
    }) 
    
    socket.on('score', (score_user, playerIds) => {
        console.log('recied id ',playerIds)
            console.log(score_user);
            if (score_user == "ST_RIGHTBALL") {
                score1 += 1;
                revealPercentage1 += 125;
                revealBlocks(revealPercentage1);
                // this.io.to(this.player1.id) .emit('score',"ST_LEFTBALL", 100);
                
            } else if (score_user == "ST_LEFTBALL") {
                score2 += 1;
                revealPercentage2 += 125;
                revealBlocks(revealPercentage2);
            }
            
        });

        

    
    // update game info
    socket.on('update', (ids, player_status, ball_status) => {
        
        playerIds = ids;
        console.log('update');
        players = [];
        for (id of ids) {
            if(players[id] == null || players[id] == undefined) { 
                players[id] = new player(player_status[id].x, player_status[id].y);
            } 
            else {
                players[id].x = player_status[id].x;
                players[id].y = player_status[id].y;
            }
        }
        ball.x = ball_status.x
        ball.y = ball_status.y
    });

    function checkOTP() {
        console.log('check',playerIds)
        const otpDigits = Array.from(document.querySelectorAll('.otp-input')).map(input => input.value).join('');
        const correctOTP = '1234'; // Change this to your correct OTP

        const resultMessage = document.getElementById('result');

        if (otpDigits === correctOTP) {
            resultMessage.textContent = 'OTP is correct!';
            resultMessage.style.color = 'green';
            
        } else {
            resultMessage.textContent = 'OTP is incorrect!';
            resultMessage.style.color = 'red';
        }
    }
</script>
<script>
    function moveToNextOrPrevious(currentInput, nextInputId) {
        const maxLength = parseInt(currentInput.getAttribute('maxlength'));
        const currentLength = currentInput.value.length;
        if (currentLength >= maxLength) {
            const nextInput = document.getElementById(nextInputId);
            if (nextInput) {
                nextInput.focus();
            }
        } else if (currentLength === 0) {
            const previousInput = currentInput.previousElementSibling;
            if (previousInput) {
                previousInput.focus();
            }
        }
    }
    function moveToPreviousOnBackspace(currentInput) {
        if (event.key === 'Backspace' && currentInput.value.length === 0) {
            const previousInput = currentInput.previousElementSibling;
            if (previousInput) {
                event.preventDefault(); // Prevent the default backspace behavior
                previousInput.focus();
            }
        }
    }
    

    
</script>
</body>
</html>