const express = require('express');
const app = express();
const http = require('http').createServer(app);
const io = require('socket.io')(http);

const Lobby = require('./lobby.js');
const RoomManager = require('./room_manager.js');

const { OAuth2Client } = require('google-auth-library');
const CLIENT_ID = '166750811137-et1b6hjpveudcbk6n5p3913dpfu7fd7e.apps.googleusercontent.com'; // Replace with your Google Client ID
const client = new OAuth2Client(CLIENT_ID);

app.use(express.json());

// Add Firebase
const admin = require('firebase-admin');
const serviceAccount = require('./ponggame-406712-firebase-adminsdk-24o90-60da6c9930.json');
admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: 'https://ponggame-406712.firebaseio.com',
});

const db = admin.firestore();

app.post('/google-signin', async (req, res) => {
    const { id_token, userId, userName, userEmail } = req.body || {};

    try {
        // Verify the Google Sign-In token
        const ticket = await client.verifyIdToken({
            idToken: id_token,
            audience: "166750811137-et1b6hjpveudcbk6n5p3913dpfu7fd7e.apps.googleusercontent.com",
        });

        // Check if the user is already signed in or add them to the database
        const userDoc = await db.collection('users').doc(userId).get();
        if (!userDoc.exists) {
            // If not, add the user to the database
            await db.collection('users').doc(userId).set({
                username: userName,
                wins: 0,
                losses: 0,
                streak: 0
            });
        }

        // Send the userId along with the success response to the client
        res.json({ success: true, message: 'Google Sign-In successful', userId });
    } catch (error) {
        // Handle errors
        console.error('Error verifying Google Sign-In token:', error);
        res.status(500).json({ success: false, message: 'Error verifying Google Sign-In token' });
    }
});

app.use(express.static('public'));

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/game.html');
});

app.get('/get-user-data', async (req, res) => {
    const userId = req.query.userId;

    try {
        // Retrieve user data from the Realtime Database based on the userId
        const userDoc = await db.collection('users').doc(userId).get();

        if (userDoc.exists) {
            const userData = userDoc.data();
            res.json(userData);
        } else {
            res.status(404).json({ message: 'User not found' });
        }
    } catch (error) {
        console.error('Error retrieving user data:', error);
        res.status(500).json({ message: 'Error retrieving user data' });
    }
});

let username = "default";
let room_code = "";
app.get('/public/:username', (req, res) => {
    res.sendFile(__dirname + '/game.html');
    username = req.params.username;
    room_code = "public";
});

let room_codes = {};
app.get('/private/:room_code/:username', (req, res) => {
    res.sendFile(__dirname + '/game.html');
    username = req.params.username;
    room_code = req.params.room_code;
});

app.get('/game.html', (req, res) => {
    res.sendFile(__dirname + '/game.html');
});

let mode = "public";
var menu_io = io.of('/menu');
menu_io.on('connection', async (socket) => {
    console.log(socket.id + " joined menu");
    let validate = 0;
    let message = "";

    let login = new Promise((resolve, reject) => {
        socket.on('join_public', (username) => {
            message = "public";
            validate = 1;
            socket.emit('public_validation', validate, message);
            socket.broadcast.emit('public_start');
        });

        socket.on('create_private', (username, room_code) => {
            if (room_codes[room_code] >= 1) {
                message = room_code + " already exists!";
                reject(message);
            } else {
                room_codes[room_code] = 1;
                validate = 1;
                socket.emit('create_validation', validate, message);
            }
        });

        socket.on('join_private', (username, room_code) => {
            if (room_codes[room_code] == null) {
                message = room_code + " does not exist!";
                reject(message);
            } else if (room_codes[room_code] === 1) {
                room_codes[room_code]++;
                validate = 1;
                socket.emit('join_validation', validate, message);
            } else if (room_codes[room_code] > 1) {
                message = "Room is full!";
                reject(message);
            }
        });

        resolve(message);
    });

    mode = await login;

    socket.on('user_signed_in', async (userData) => {
        const { username, id } = userData;

        const userDoc = await db.collection('users').doc(id).get();
        if (!userDoc.exists) {
            await db.collection('users').doc(id).set({ username, wins: 0, losses: 0, streak: 0 });
        }

        const userSnapshot = await db.collection('users').doc(id).get();
        const userDataFromDB = userSnapshot.data();
        playersData[id] = userDataFromDB;

        socket.emit('user_signed_in_success');
    });

    socket.on('game_over', ({ winner, loser }) => {
        playersData[winner].wins++;
        playersData[loser].losses++;

        io.emit('update_player_data', playersData);
    });
});

const playersData = {};

var game_io = io.of('/game');
let lobby = new Lobby();
let room_manager = new RoomManager(game_io);
game_io.on('connection', (socket) => {
    console.log(socket.id + " joined game");
    lobby.add_player(socket.id, username, room_code);

    if (lobby.get_num_player() % 2 == 0 && lobby.get_num_player() > 0) {
        let player1 = lobby.public_queue.shift();
        let player2 = lobby.public_queue.shift();
        room_manager.create_room(player1, player2);
    }
    if (lobby.get_num_private_players(room_code) == 2) {
        let player1 = lobby.private_players[room_code].shift();
        let player2 = lobby.private_players[room_code].shift();
        room_manager.create_room(player1, player2);
    }
    const playerWinStreaks = {};
    let gameEndTime;

    socket.on('game_over', ({ winner, loser }) => {
        playerWinStreaks[winner] = (playerWinStreaks[winner] || 0) + 1;

        io.emit('update_win_streaks', playerWinStreaks);

        gameEndTime = Date.now() + 24 * 60 * 60 * 1000;

        io.emit('update_game_end_time', gameEndTime);
    });

    socket.on('disconnect', () => {
        const room = room_manager.find_room(socket.id);
        if (room != null) {
            room.disconnect(socket.id);
        }
        if (room_codes[room_code] != null) {
            delete room_codes[room_code];
            delete lobby.private_players[room_code];
        }
        lobby.remove_player(socket.id);
    });

    socket.on('keydown', (keycode) => {
        if (room_manager.num_rooms > 0) {
            let user = room_manager.find_user(socket.id);
            if (user != null) {
                if (keycode != 32) {
                    room_manager.find_user(socket.id).keypress[keycode] = true;
                }
            }
        }
    });

    socket.on('keyup', (keycode) => {
        if (room_manager.num_rooms > 0) {
            let user = room_manager.find_user(socket.id);
            if (user != null) {
                room_manager.find_user(socket.id).keypress[keycode] = false;
            }
        }
    });

    socket.on('score', (score_user, playerIds) => {
        console.log('received id ', playerIds);
        console.log(score_user);

        if (score_user == "ST_RIGHTBALL" || score_user == "ST_LEFTBALL") {
            ball.speed = initialSpeed;
            revealPercentage1 += 125;
            revealBlocks(revealPercentage1);
            revealPercentage2 += 125;
            revealBlocks(revealPercentage2);
        }
    });

    socket.on('update_win_streaks', (winStreaks) => {
        const winStreakElement = document.getElementById('winStreak');
        winStreakElement.textContent = winStreaks[playerIds[1]] || 0; // Assuming playerIds[1] is the winner
    });

    socket.on('update_game_end_time', (endTime) => {
        const timeRemainingElement = document.getElementById('timeRemaining');

        function updateTimer() {
            const currentTime = Date.now();
            const timeDiff = endTime - currentTime;

            if (timeDiff > 0) {
                const hours = Math.floor(timeDiff / (60 * 60 * 1000));
                const minutes = Math.floor((timeDiff % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((timeDiff % (60 * 1000)) / 1000);

                timeRemainingElement.textContent = `${hours}:${minutes}:${seconds}`;
            } else {
                timeRemainingElement.textContent = 'Time expired';
            }
        }

        setInterval(updateTimer, 1000);

        updateTimer();
    });

    socket.on('space_event', (space) => {
        if (room_manager.num_rooms > 0) {
            let user = room_manager.find_user(socket.id);
            const SPACE = 32;
            if (user != null) {
                if (space == 1) {
                    room_manager.find_user(socket.id).keypress[SPACE] = true;
                } else if (space == 0) {
                    room_manager.find_user(socket.id).keypress[SPACE] = false;
                }
            }
        }
    });
});

app.use((req, res, next) => {
    if (req.path === '/') {
        res.redirect('/loading');
    } else {
        next();
    }
});

var update = setInterval(() => {
    room_manager.update();
}, 30);

const port = 3000;
http.listen(port, () => {
    console.log("listening on port " + port);
});

room logic below


const Ball = require('./ball.js')
const Player = require('./player.js')
const config = {
    screen_width,
    screen_height,
    player_width,
    player_height,
    end_point
} = require('./config.json');

let gmcheck = "";

const game_state = ["ST_IDLE", "ST_DISCONNECTED", "ST_ONGAME", "ST_LEFTBALL", "ST_RIGHTBALL"];
const UP = 38, DOWN = 40, SPACE = 32;


module.exports = class room {
    constructor(p1, p2, io) {
        this.player1 = new Player(p1, config.player_width, (config.screen_height - config.player_height)/ 2);
        this.player2 = new Player(p2, config.screen_width - config.player_width * 2, (config.screen_height - config.player_height) / 2);
        this.ball    = new Ball((config.screen_width - config.player_width) / 2, (config.screen_height - config.player_width) / 2);
        this.curr_state = "ST_IDLE";
        this.id = p1.id + p2.id;
        this.io = io;
        this.game_done = false;

        this.players = [];
        this.players.push(this.player1);
        this.players.push(this.player2);

        
       
    }
    init() {
        let usernames = [this.player1.username, this.player2.username];
        this.io.to(this.player1.id).emit('usernames', usernames);
        this.io.to(this.player2.id).emit('usernames', usernames)
        this.io.to(this.player1.id).emit('config', config);
        this.io.to(this.player2.id).emit('config', config);
    }



    
    update() {

        
        let status = {};
        let ids = [];
        // Determine player to start.
        // this.io.to(this.player1.id) .emit('score',"ST_LEFTBALL", this.player1.points);
        // this.io.to(this.player2.id).emit('score', "ST_RIGHTBALL", this.player2.points);
// console.log(gmcheck);

        let start_player = this.player1;
        if(this.curr_state === "ST_RIGHTBALL") {
            start_player = this.player2;
        }

        this.players.forEach(player => {
            if(player.keypress[UP] && player.to_trans.y >= 0) {
                player.to_trans.y -= 7;
            }
            if(player.keypress[DOWN] && player_height + player.to_trans.y < config.screen_height) {
                player.to_trans.y += 7;
            }
            if(start_player.keypress[SPACE] && this.curr_state != "ST_ONGAME"
               && this.curr_state != "ST_GAMEOVER" 
               && (this.curr_state == "ST_LEFTBALL" || this.curr_state == "ST_RIGHTBALL" 
               || this.curr_state == "ST_IDLE")) {
                this.ball.vel_x = this.ball.speed;
                this.curr_state = "ST_ONGAME"
            }
            ids.push(player.id);
            status[player.id] = player.to_trans;
        });

       


        if((this.player1.points == config.end_point
        || this.player2.points == config.end_point)
        && this.curr_state != "ST_GAMEOVER"
        && this.game_done == false) {
            let winner = this.curr_state === "ST_RIGHTBALL" ? this.player1.username : this.player2.username;
            if(this.curr_state==="ST_RIGHTBALL"){
                let winning_text = winner + 'you Won!';
                let lossing_text = winner + 'you loss!';
                this.io.to(this.player1.id).emit('game_over', winning_text);
                this.io.to(this.player2.id).emit('game_over', lossing_text);
            }
            else{
                let winning_text = winner + 'you Won!';
                let lossing_text = winner + 'you loss!';
                this.io.to(this.player1.id).emit('game_over', lossing_text);
                this.io.to(this.player2.id).emit('game_over', winning_text);
            }
            // let winning_text = winner + ' Won!';
            // this.curr_state = "ST_GAMEOVER";
            // this.io.to(this.player1.id).emit('game_over', winning_text);
            // this.io.to(this.player2.id).emit('game_over', winning_text);
            this.game_done = true;
        }

       

        if(this.game_done == false) {
            this.curr_state = this.ball.update(this.player1, this.player2, this.curr_state, this.io);
            this.io.to(this.player1.id).emit('update', ids, status, this.ball.to_trans);
            this.io.to(this.player2.id).emit('update', ids, status, this.ball.to_trans);
        }
    }

   

    
    
    disconnect(id) {
        this.curr_state = "ST_DISCONNECTED"
        let disconnected_user = (id === this.player1.id) ? this.player1.username : this.player2.username;
        let connected_id = (id === this.player1.id) ? this.player2.id : this.player1.id;
        let msg = disconnected_user + " has left the game";
        this.io.to(connected_id).emit('game_over', msg);
        console.log(msg);
    }

    print_room() {
        console.log("----------------------------------")
        console.log("Room ID: " + this.id);
        console.log("player 1: " + this.player1.username + "(" + this.player1.id + ")");
        console.log("player 2: " + this.player2.username + "(" + this.player2.id + ")");
        console.log("----------------------------------")
    }
}
room manager logic belowconst Room = require('./room.js')
module.exports = class room_manager {
    constructor(io){
        this.rooms = {};
        this.num_rooms = 0;
        this.io = io;
    }

    create_room(p1, p2) {
        let to_add = new Room(p1, p2, this.io);
        to_add.init();
        console.log('Room Created!');
        this.rooms[to_add.id] = to_add;
        this.rooms[to_add.id].print_room();
        this.num_rooms++;
    }

    destroy(room) {
        this.num_rooms--;
        delete this.rooms[room.id];
    }

    update() {
        for(var id in this.rooms) {
            this.rooms[id].update();
        }
    }

    find_room(to_find) {
        let room = {};
        for(var id in this.rooms) {
            if(id.includes(to_find) == true) {
                room = this.rooms[id];
                return room;
            }
        }
    }

    find_user(to_find) {
        let user = {};
        for(var id in this.rooms) {
            if(id.includes(to_find) == true) {
                let room = this.rooms[id];
                user = room.player1.id === to_find ? room.player1 : room.player2;
                return user;
            }
        }
    }

    print_all_rooms() {
        for (var id in this.rooms) {
            this.rooms[id].print_room();
        }
        console.log("num rooms: " + this.num_rooms);
    }
}
below lobby.js 
module.exports = class lobby {
    constructor() {
        this.players = {};
        this.public_queue = [];
        this.private_players = {};
        this.num_player = 0;
    }

    add_player(id, username, room_code = "public") {
        let player = {
            id: id,
            username: username,
            room_code: room_code
        }
        if(player.room_code === "public") {
            this.players[id] = player;
            this.public_queue.push(player);
            this.num_player++;
        } else {
            if(this.private_players[room_code] == null) {
                this.private_players[room_code] = new Array();
            }
            this.private_players[room_code].push(player);
        }
    }

    remove_player(id) {
        if(this.players[id] != null) {
            this.public_queue.shift();
            delete this.players[id];
            this.num_player--;
        } 
    }

    get_num_player() {
        return this.public_queue.length;
    }

    get_num_private_players(code) {
        return this.private_players[code] == null ? 0 : this.private_players[code].length;
    }
}

player js belowmodule.exports = class player{
    constructor(info, xpos = 0, ypos = 0) {
        this.to_trans = {};
        this.to_trans.x = xpos;
        this.to_trans.y = ypos;
        this.points = 0;

        this.username = info.username;
        this.id = info.id;
        this.keypress = [];
        this.keyonce = [];
        
        // HARD-CODED
        this.width = 20;
        this.height = 100
    }
};

ball js belowmodule.exports = class ball{
    constructor(xpos, ypos) {
        this.to_trans = {};
        this.to_trans.x = xpos;
        this.to_trans.y = ypos;
        this.speed = 15;
        this.vel_x = this.speed;
        this.vel_y = 0;

        // For testing, it is hard-coded now.
        this.side = 20;
    }
    update(left_player, right_player, curr_state, io) {
        let pi = Math.PI;

        // HARD-CODED
        const WIDTH = 700;
        const HEIGHT = 600;

        const reset_offset = 5;

        if(curr_state === "ST_IDLE") {
            this.vel_x = 0;    
            this.vel_y = 0;    
        } else if(curr_state === "ST_LEFTBALL") {
            this.to_trans.x = (left_player.width * 2) + reset_offset;
            this.to_trans.y = left_player.to_trans.y + (left_player.height / 2) - (this.side / 2);
            this.speed = 15;
            this.vel_x = 0;    
            this.vel_y = 0;    
        } else if (curr_state === "ST_RIGHTBALL") {
            this.to_trans.x = WIDTH - (right_player.width * 2) - this.side - reset_offset;
            this.to_trans.y = right_player.to_trans.y + (right_player.height / 2) - (this.side / 2);
            this.speed = -15;
            this.vel_x = 0;    
            this.vel_y = 0;    
        } 
        if (curr_state === "ST_ONGAME") {
            this.to_trans.x += this.vel_x;
            this.to_trans.y += this.vel_y;
            // score condition
            if (this.to_trans.x <= 0) {
                curr_state = "ST_LEFTBALL"
                // io.to(left_player.id).emit('score', curr_state);

                // io.to(left_player.id) .emit('score',"ST_LEFTBALL", left_player.points);
                io.to(right_player.id).emit('score', curr_state);
                right_player.points += 1;
            }
            if (this.to_trans.x > WIDTH) {
                curr_state = "ST_RIGHTBALL"
                io.to(left_player.id).emit('score', curr_state);
                // io.to(right_player.id).emit('score',"ST_RIGHTBALL", right_player.points);
                // io.to(right_player.id).emit('score', curr_state);
                left_player.points += 1;
            }
            // proceed physics only if game is on going
            if (this.to_trans.y < 0 || this.to_trans.y + this.side > HEIGHT) {
                var offset = this.vel_y < 0 ? 0 - this.to_trans.y : HEIGHT - (this.to_trans.y + this.side);
                this.to_trans.y += 2 * offset;
                this.vel_y *= -1;
            }

            var AABBIntersection = (ax, ay, aw, ah, bx, by, bw, bh) => {
                return ax < bx + bw && ay < by + bh && bx < ax + aw && by < ay + ah;
            }

            let paddle = this.vel_x < 0 ? left_player : right_player;
            if (AABBIntersection(paddle.to_trans.x, paddle.to_trans.y, paddle.width, paddle.height, this.to_trans.x, this.to_trans.y, this.side, this.side)) {
                this.to_trans.x = paddle === left_player ? left_player.to_trans.x + left_player.width : right_player.to_trans.x - this.side;
                let n = (this.to_trans.y + this.side - paddle.to_trans.y) / (paddle.height + this.side);
                let phi = 0.25 * pi * (2 * n - 1);
                let abs_speed = this.speed < 0 ? this.speed * -1 : this.speed;
                this.vel_x = (paddle === left_player ? 1 : -1) * abs_speed* Math.cos(phi);
                this.vel_y = abs_speed * Math.sin(phi);
            }
        }
        return curr_state;
    }
};
 const socket = io('/game');
        let width = 0, height = 0, player_width = 0, player_height;
        const pi = Math.PI;
        const UP = 38, DOWN = 40;
        let canvas, ctx, keystate;
        let ball;
        let message = "";
        let score1 = 0, score2 = 0;
        let username = [];
        let initialSpeed = 8;
        let space_down = false;
        let revealPercentage1 = 1;
        let playerSpeed = 1199;
        let revealPercentage2 = 1;

        let playerIds = [];

        // send key code to server.
        $('body').on('keydown', (e) => {
            socket.emit('keydown', e.keyCode);
            console.log(e.keyCode);
            if (e.keyCode == 32) {
                let space = 0;
                if (space_down == false) {
                    space = 1;
                    space_down = true;
                } else {
                    space = 0;
                }
                socket.emit('space_event', space)
            }
        });
        $('body').on('keyup', (e) => {
            socket.emit('keyup', e.keyCode);
            if (e.keyCode == 32) {
                space_down = false;
            }
        });
        let players = [];
        class player {
            constructor(xpos = 0, ypos = 0) {
                this.x = xpos;
                this.y = ypos;
                this.width = 0
                this.height = 0;
                this.username = "";
            }
            init() {
            }
            update() {
                this.width = player_width;
                this.height = player_height;
            }
            draw() {
                // Set the fill color based on the player index
                if (this.x < width / 2) {
                    ctx.fillStyle = "#FFB6C1"; // Magenta for left paddle
                } else {
                    ctx.fillStyle = "#ADD8E6"; // Green for right paddle
                }
                const cornerRadius = 10; // You can adjust this value
                ctx.beginPath();
                ctx.moveTo(this.x + cornerRadius, this.y);
                ctx.lineTo(this.x + this.width - cornerRadius, this.y);
                ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + cornerRadius);
                ctx.lineTo(this.x + this.width, this.y + this.height - cornerRadius);
                ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - cornerRadius, this.y + this.height);
                ctx.lineTo(this.x + cornerRadius, this.y + this.height);
                ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - cornerRadius);
                ctx.lineTo(this.x, this.y + cornerRadius);
                ctx.quadraticCurveTo(this.x, this.y, this.x + cornerRadius, this.y);
                ctx.fill();
            }
        };
        ball = {
            x: null,
            y: null,
            vel: null,
            side: 0,
            // speed: 8,
            update: function () {
            },
            draw: function () {
                ctx.beginPath();
                ctx.arc(this.x + this.side / 2, this.y + this.side / 2, this.side / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        function init() {
            ball.side = player_width;
            ball.x = (width - ball.side) / 2;
            ball.y = (height - ball.side) / 2;
            console.log(player_width);
            ball.vel = {
                x: ball.speed,
                y: 0
            };
        }
        function update() {
            if (Math.floor(Date.now() / 1000) % 5 === 0) {
                ball.speed += 1;
            }

            // Check for ball bouncing
            if (ball.y <= 0 || ball.y + ball.side >= height) {
                // Increase speed on bounce
                ball.speed += 1;
            }

            ball.update();
            for (p in players) {
                players[p].update();
            }

        }
        document.addEventListener('keydown', (event) => {
            switch (event.keyCode) {
                case 37: // Left arrow key
                    player.x -= playerSpeed;
                    break;
                case 39: // Right arrow key
                    player.x += playerSpeed;
                    break;
                case 38: // Up arrow key
                    player.y -= playerSpeed;
                    break;
                case 40: // Down arrow key
                    player.y += playerSpeed;
                    break;
            }
        });
        function draw() {
            // Draw the background image
            var modal = document.getElementById('imageModal');
            modal.style.display = 'block';
            // ctx.drawImage(bgImage, 0, 0, width, height); // Uncomment this line if you want to draw the background image first
            const margin = 100;
            ctx.fillStyle = "rgba(0, 0, 0, 0.419)";
            ctx.fillRect(0, 0, width, height);
            ctx.save();
            ctx.fillStyle = "#fff";
            for (p in players) {
                players[p].draw();
            }
            ctx.fillStyle = "#fff";
            ball.draw();
            var mid_width = 4;
            var x = (width - mid_width) * 0.5;
            var y = 0;
            var step = height / 20;
            // Messages
            ctx.font = "30px Arial";
            ctx.fillText(message, 0, height - 50);
            // Scores
            ctx.font = "50px Arial";
            ctx.fillStyle = "#fff";
            // ctx.fillText(score1, width / 4 - ctx.measureText(score1).width / 2, height / 5);
            ctx.fillStyle = "#fff";
            // ctx.fillText(score2, 3 * width / 4 - ctx.measureText(score2).width / 2, height / 5);
            // Usernames: Centered on both sides
            ctx.font = "30px Arial";
            // ctx.fillStyle = "#ff00ff"; // Magenta color for left stick bars
            const username1Width = ctx.measureText(username[0]).width;
            // ctx.fillText(username[0], width / 4 - username1Width / 2, height / 8);
            // ctx.fillStyle = "#00ff00"; // Green color for right stick bars
            const username2Width = ctx.measureText(username[1]).width;
            // ctx.fillText(username[1], 3 * width / 4 - username2Width / 2, height / 8);
            ctx.restore();
            // ctx.fillText(username[0], width / 4 - username1Width / 2, height / 8);
            // ctx.fillText(username[1], 3 * width / 4 - username2Width / 2, height / 8);
            ctx.restore();
            // Draw the background image again to cover up any other drawn elements
            // ctx.drawImage(bgImage, 0, 0, width, height);
        }
        function createGrid() {
            const container = document.getElementById("container");

            for (let i = 0; i < 2500; i++) {
                const block = document.createElement("div");
                block.classList.add("block");
                container.appendChild(block);
            }
        }
        function revealBlocks(revealPercentage) {
            // Maintain a list of previously revealed blocks
            revealPercentage = revealPercentage;
            const previouslyRevealedBlocks = [];
            const inputNumber = revealPercentage;
            const blocks = document.querySelectorAll(".block");
            // Randomly select and reveal the specified number of blocks
            var delayInMilliseconds = 1000;
            const blocksToReveal = [];
            for (let i = 0; i < inputNumber; i++) {
                // Check if the block has already been revealed
                let blockIndex = Math.floor(Math.random() * blocks.length);
                while (previouslyRevealedBlocks.includes(blockIndex)) {
                    blockIndex = Math.floor(Math.random() * blocks.length);
                }
                previouslyRevealedBlocks.push(blockIndex);
                blocksToReveal.push(blocks[blockIndex]);

            }
            // Set the background color of the selected blocks to transparent
            blocksToReveal.forEach(block => {
                block.style.transition = "background-color 0.7s ease-in-out";
                block.style.backgroundColor = "transparent";

            });
        }

        window.addEventListener("load", createGrid);
        function showImagePopup() {
            var modal = document.getElementById('imageModal');
            modal.style.display = 'block';
            revealBlocks();
        }
        // Function to handle submitting guesses
        function submitGuess() {
            var guess = document.getElementById('guessInput').value;
            // TODO: Check if the guess is correct and take appropriate actions
            // Close the modal after processing the guess
            var modal = document.getElementById('imageModal');
            modal.style.display = 'none';
        }
        var bgImage = new Image();
        bgImage.src = data[0].photo;
        function main() {
            canvas = document.createElement("canvas");
            ctx = canvas.getContext("2d");
            document.body.appendChild(canvas);
            var bgImage = new Image();
            bgImage.src = data[0].photo;
            bgImage.onload = function () {
                ctx.drawImage(bgImage, 0, 0, width, height);
            };
            var loop = function () {
                canvas.width = width;
                canvas.height = height;
                update();
                draw();
                window.requestAnimationFrame(loop, canvas);
            }
            window.requestAnimationFrame(loop, canvas);
        }
        main();
        socket.on('config', (config) => {
            width = config.screen_width;
            height = config.screen_height;
            player_width = config.player_width;
            player_height = config.player_height;
            end_point = config.end_point;
            init();
        })
        socket.on('usernames', (usernames) => {
            username.push(usernames[0]);
            username.push(usernames[1]);
        })
        socket.on('game_over', (msg) => {
            message = msg;
            // Create the button
            let leave_button = document.createElement("button");
            leave_button.innerHTML = "Go Back To Menu";
            // Append somewhere
            let body = document.getElementsByTagName("body")[0];
            body.appendChild(leave_button);
            // Add event handler
            leave_button.addEventListener("click", function () {
                window.location.href = '/';
            });
        })

        socket.on('score', (score_user, playerIds) => {
            console.log('recied id ', playerIds)
            console.log(score_user);
            if (score_user == "ST_RIGHTBALL") {
                score1 += 1;
                revealPercentage1 += 125;
                revealBlocks(revealPercentage1);
                // this.io.to(this.player1.id) .emit('score',"ST_LEFTBALL", 100);

            } else if (score_user == "ST_LEFTBALL") {
                score2 += 1;
                revealPercentage2 += 125;
                revealBlocks(revealPercentage2);
            }

        });




        // update game info
        socket.on('update', (ids, player_status, ball_status) => {

            playerIds = ids;
            console.log('update');
            players = [];
            for (id of ids) {
                if (players[id] == null || players[id] == undefined) {
                    players[id] = new player(player_status[id].x, player_status[id].y);
                }
                else {
                    players[id].x = player_status[id].x;
                    players[id].y = player_status[id].y;
                }
            }
            ball.x = ball_status.x
            ball.y = ball_status.y
        });
        above is game logic somehow